library fclone;

import 'dart:convert';
import 'dart:io';

import 'package:archive/archive_io.dart';
import 'package:args/args.dart';
import 'package:flutter_native_splash/cli_commands.dart';
import 'package:http/http.dart';
import 'package:icons_launcher/cli_commands.dart';
import 'package:json2yaml/json2yaml.dart';
import 'package:package_rename/package_rename.dart' as package_rename;
import 'package:yaml/yaml.dart';

/// A Calculator.
class FClone {
  String? path;
  List<String>? pathList;
  String? backupName;
  static FClone? _instance;

  FClone._internal();

  static FClone get instance => _getInstance();

  static FClone _getInstance() {
    _instance ??= FClone._internal();
    return _instance!;
  }

  List<String> impFiles = [
    'package_rename_config.json',
    'icons_launcher.json',
    'flutter_native_splash.json',
  ];
  String fcloneConstants = 'fclone_constants.json';
  String fcloneReplaceFile = 'fclone_replace_file.json';

  void exec(List<String> arguments) {
    loadKeys(arguments);
  }

  void backup(List<String> arguments) {
    loadKeys(arguments, isBackup: true);
  }

  Future<void> loadKeys(List<String> arguments, {bool isBackup = false}) async {
    if (arguments.isEmpty) {
      final parsedArgs = await loadConfigFile();
      if (parsedArgs['backup_path'] is List) {
        pathList = List<String>.from((parsedArgs['backup_path'] as YamlList)
            .value
            .map((e) => e.toString()));
      }
      path = parsedArgs['path'];
      backupName = parsedArgs['backup_name'];
    } else {
      final parser = ArgParser();
      parser.addOption('path', abbr: 'p');
      parser.addOption('backup_name', abbr: 'bn');
      parser.addMultiOption('backup_paths');
      final parsedArgs = parser.parse(arguments);
      if (parsedArgs['backup_path'] is List) {
        pathList = parsedArgs['backup_path'];
      }
      path = parsedArgs['path'];
      backupName = parsedArgs['backup_name'];
    }
    if (!isBackup) {
      if (path == null) {
        flog(
            'error path not found please specify path where you store your zip file');
      } else {
        if (Uri.parse(path!).isAbsolute) {
          flog('path is a url will download zip...');
          await getZipFromUrl(path!);
        } else {
          File file = File(path!);
          if (!await file.exists()) {
            flog('error path not found $path');
          } else {
            await generateFiles(file);
          }
        }
      }
    } else {
      backupAll();

      /// will do...
    }
  }

  Future<Map<String, dynamic>> loadConfigFile() async {
    final File file = File('pubspec.yaml');
    final String yamlString = await file.readAsString();
    final Map yamlMap = loadYaml(yamlString);
    if (yamlMap['fclone'] is! Map) {
      throw Exception('fclone was not found');
    }
    final Map<String, dynamic> config = <String, dynamic>{};
    for (MapEntry<dynamic, dynamic> entry in yamlMap['fclone'].entries) {
      config[entry.key] =
          (entry.value is List) ? entry.value : entry.value.toString();
    }

    return config;
  }

  flog(String s) {
    print('FCLONE :: $s');
  }

  Future<void> generateFiles(File file) async {
    Directory directory = Directory('fclone');

    ///unarchive zip file...
    try {
      final inputStream = InputFileStream(file.path);
      final archive = ZipDecoder().decodeBuffer(inputStream);
      extractArchiveToDisk(archive, 'fclone');
    } catch (e) {
      flog('$e');
    }

    /// working on consts ...
    File fcloneConsts = File('${directory.path}/$fcloneConstants');
    if (await fcloneConsts.exists()) {
      await generateConstantsFromJson(fcloneConsts);
    }

    /// working on file replacing if needed. like logos etc...
    File fcloneReplace = File('${directory.path}/$fcloneReplaceFile');
    if (await fcloneReplace.exists()) {
      await replaceFilesFromJson(fcloneReplace);
    }

    /// generate icon,name,splash screen files and run same time..
    await Future.forEach(impFiles, (element) async {
      File incoming = File('${directory.path}/$element');
      File outGoing = File(element.toString().replaceAll('.json', '.yaml'));
      if (await incoming.exists()) {
        if (await outGoing.exists()) {
          await outGoing.delete();
        }
        String data = json2yaml(jsonDecode(await incoming.readAsString()));
        await outGoing.writeAsString(
          '# Generated By Bikramaditya From Fclone\n$data',
        );
        await runYamlFile(element.toString().replaceAll('.json', ''));
      }
    });
  }

  Future<void> runYamlFile(String name) async {
    switch (name) {
      case 'package_rename_config':
        try {
          package_rename.set([]);
        } catch (e) {
          flog('error on package rename ::$e');
        }
        break;
      case 'icons_launcher':
        try {
          createLauncherIcons(path: 'icon_launcher.yaml', flavor: null);
        } catch (e) {
          flog('error on icon launcher :: $e');
        }
        break;
      case 'flutter_native_splash':
        try {
          createSplash(
            path: 'flutter_native_splash.yaml',
            flavor: null,
          );
        } catch (e) {
          flog('error on native splash :: $e');
        }
        break;
    }
  }

  Future<void> generateConstantsFromJson(File fcloneConsts) async {
    try {
      File fcloneFile =
          File('lib/${fcloneConstants.replaceAll('.json', '.dart')}');
      Map jsonData = jsonDecode(await fcloneConsts.readAsString());
      String data = '/// Generated By Bikramaditya From Fclone\n';
      if (jsonData.containsKey('import_fclone')) {
        List<String> imports = List<String>.from(jsonData['import_fclone']);
        for (var element in imports) {
          data += "$element\n";
        }
        jsonData.remove('import_fclone');
      }
      data += '\n\nclass FcloneConstants {\n\n';
      jsonData.forEach((key, value) {
        data += 'static var $key= $value ;\n';
      });
      data += '\n}';
      await fcloneFile.writeAsString(data);
    } catch (e) {
      flog('error on formatting constants :: $e');
    }
  }

  Future<void> replaceFilesFromJson(File fcloneReplace) async {
    try {
      Map jsonData = jsonDecode(await fcloneReplace.readAsString());
      await Future.forEach(jsonData.entries, (element) async {
        File file1 = File('${element.key}'); // old file
        File file2 = File('${element.value}'); // new file
        if (await file2.exists()) {
          if (await file1.exists()) {
            await file1.delete();
          }
          await file2.copy(file1.path);
        } else {
          flog('error file not found :: ${file2.path}');
        }
      });
    } catch (e) {
      flog('error on replacing files :: $e');
    }
  }

  Future<void> getZipFromUrl(String s) async {
    final request = Request('GET', Uri.parse(s));
    final StreamedResponse response = await Client().send(request);

    final contentLength = response.contentLength;
    // final contentLength = double.parse(response.headers['x-decompressed-content-length']);
    List<int> bytes = [];

    File file = File('fclone.zip');
    response.stream.listen(
      (List<int> newBytes) {
        bytes.addAll(newBytes);
        final downloadedLength = bytes.length;
        flog(
            'downloading ... :: ${(downloadedLength / (contentLength ?? 1)) * 100}');
      },
      onDone: () async {
        flog('downloaded');
        await file.writeAsBytes(bytes);
        await generateFiles(file);
      },
      onError: (e) {
        flog('error on downloading :: $e');
      },
      cancelOnError: true,
    );
  }

  Future<void> backupAll() async {
    Directory? directory = Directory('${backupName ?? ''}_fclone');

    /// backup icon,name,splash screen files and run same time..
    await Future.forEach(impFiles, (element) async {
      File incoming = File(element.toString().replaceAll('.json', '.yaml'));
      File outGoing = File('${directory.path}/$element');
      if (await incoming.exists()) {
        if (await outGoing.exists()) {
          await outGoing.delete();
        }
        await outGoing.create();

        final Map yamlMap = loadYaml(await incoming.readAsString());
        await outGoing.writeAsString(
          '$yamlMap',
        );
      }
    });
  }
}
